<?php

namespace App\Http\Controllers\Teacher;

use App\Http\Controllers\Controller;
use App\Models\QuizSession;
use App\Models\Student;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\ValidationException;
use Illuminate\Support\Facades\Log;

class QuizSessionController extends Controller
{
    /**
     * Liste toutes les sessions du prof connectÃ©
     */
    public function index()
    {
        $teacher = Auth::user()->teacher;

        if (!$teacher) {
            return response()->json(['error' => 'AccÃ¨s rÃ©servÃ© aux enseignants'], 403);
        }

        $sessions = QuizSession::where('teacher_id', $teacher->id)
            ->with('quiz')
            ->latest()
            ->get();

        return response()->json($sessions);
    }

    /**
     * CrÃ©er une nouvelle session de quiz
     */
    public function store(Request $request)
    {
        $teacher = Auth::user()->teacher;

        if (!$teacher) {
            return response()->json(['error' => 'AccÃ¨s rÃ©servÃ© aux enseignants'], 403);
        }

        // ðŸ”§ Debug temporaire pour voir ce qui se passe
        Log::info('QuizSession creation attempt', [
            'request_data' => $request->all(),
            'teacher_id' => $teacher->id
        ]);

        try {
            // âœ… Validation de base RENFORCÃ‰E
            $validated = $request->validate([
                'quiz_id' => 'required|exists:quizzes,id',
                'title' => 'required|string|max:255',
                'starts_at' => 'required|date|after:now',
                'ends_at' => 'required|date|after:starts_at',
                'max_participants' => 'nullable|integer|min:1',
                'require_student_list' => 'boolean',
                'allowed_students' => 'nullable|array|max:100',
                'allowed_students.*' => 'required|integer|exists:students,id',
                'settings' => 'nullable|array',
            ], [
                'allowed_students.*.exists' => 'Un ou plusieurs Ã©tudiants sÃ©lectionnÃ©s n\'existent pas.',
                'allowed_students.*.integer' => 'Les identifiants d\'Ã©tudiants doivent Ãªtre des nombres.',
                'starts_at.after' => 'La date de dÃ©but doit Ãªtre dans le futur.',
                'ends_at.after' => 'La date de fin doit Ãªtre aprÃ¨s la date de dÃ©but.',
            ]);

            Log::info('Basic validation passed', ['validated' => $validated]);

        } catch (ValidationException $e) {
            Log::error('Validation failed', ['errors' => $e->errors()]);
            return response()->json([
                'message' => 'Erreur de validation',
                'errors' => $e->errors()
            ], 422);
        }

        // âœ… Validation supplÃ©mentaire pour l'institution (si applicable)
        if (!empty($validated['allowed_students'])) {
            try {
                $this->validateStudentsInstitution($validated['allowed_students'], $teacher);
            } catch (ValidationException $e) {
                return response()->json([
                    'message' => 'Erreur de validation des Ã©tudiants',
                    'errors' => $e->errors()
                ], 422);
            }
        }

        try {
            $session = new QuizSession($validated);
            $session->teacher_id = $teacher->id;
            $session->status = 'scheduled';
            $session->generateSessionCode();
            $session->save();

            Log::info('QuizSession created successfully', ['session_id' => $session->id]);

            return response()->json([
                'message' => 'Session crÃ©Ã©e avec succÃ¨s',
                'session' => $session->load('quiz')
            ], 201);

        } catch (\Exception $e) {
            Log::error('Error creating QuizSession', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return response()->json([
                'message' => 'Erreur lors de la crÃ©ation de la session',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Voir une session
     */
    public function show($id)
    {
        $teacher = Auth::user()->teacher;

        $session = QuizSession::with('quiz')->findOrFail($id);

        if (!$teacher || $session->teacher_id !== $teacher->id) {
            return response()->json(['error' => 'Non autorisÃ©'], 403);
        }

        return response()->json($session);
    }

    /**
     * Modifier une session
     */
    public function update(Request $request, $id)
    {
        $teacher = Auth::user()->teacher;

        $session = QuizSession::findOrFail($id);

        if (!$teacher || $session->teacher_id !== $teacher->id) {
            return response()->json(['error' => 'Non autorisÃ©'], 403);
        }

        // VÃ©rifier si la session peut Ãªtre modifiÃ©e
        if (in_array($session->status, ['active', 'completed', 'cancelled'])) {
            return response()->json([
                'error' => 'Impossible de modifier une session active, terminÃ©e ou annulÃ©e'
            ], 400);
        }

        try {
            // âœ… Validation de base RENFORCÃ‰E
            $validated = $request->validate([
                'title' => 'sometimes|string|max:255',
                'starts_at' => 'sometimes|date|after:now',
                'ends_at' => 'sometimes|date|after:starts_at',
                'max_participants' => 'nullable|integer|min:1',
                'require_student_list' => 'boolean',
                'allowed_students' => 'nullable|array|max:100',
                'allowed_students.*' => 'required|integer|exists:students,id',
                'settings' => 'nullable|array',
            ], [
                'allowed_students.*.exists' => 'Un ou plusieurs Ã©tudiants sÃ©lectionnÃ©s n\'existent pas.',
                'allowed_students.*.integer' => 'Les identifiants d\'Ã©tudiants doivent Ãªtre des nombres.',
            ]);

        } catch (ValidationException $e) {
            return response()->json([
                'message' => 'Erreur de validation',
                'errors' => $e->errors()
            ], 422);
        }

        // âœ… Validation supplÃ©mentaire pour l'institution
        if (!empty($validated['allowed_students'])) {
            try {
                $this->validateStudentsInstitution($validated['allowed_students'], $teacher);
            } catch (ValidationException $e) {
                return response()->json([
                    'message' => 'Erreur de validation des Ã©tudiants',
                    'errors' => $e->errors()
                ], 422);
            }
        }

        $session->update($validated);

        return response()->json([
            'message' => 'Session mise Ã  jour avec succÃ¨s',
            'session' => $session->fresh()->load('quiz')
        ]);
    }

    /**
     * Activer une session
     */
    public function activate($id)
    {
        $teacher = Auth::user()->teacher;

        $session = QuizSession::findOrFail($id);

        if (!$teacher || $session->teacher_id !== $teacher->id) {
            return response()->json(['error' => 'Non autorisÃ©'], 403);
        }

        if ($session->status !== 'scheduled') {
            return response()->json([
                'error' => 'Seules les sessions programmÃ©es peuvent Ãªtre activÃ©es'
            ], 400);
        }

        $session->update([
            'status' => 'active',
            'activated_at' => now()
        ]);

        return response()->json([
            'message' => 'Session activÃ©e avec succÃ¨s',
            'session' => $session
        ]);
    }

    /**
     * Terminer une session
     */
    public function complete($id)
    {
        $teacher = Auth::user()->teacher;

        $session = QuizSession::findOrFail($id);

        if (!$teacher || $session->teacher_id !== $teacher->id) {
            return response()->json(['error' => 'Non autorisÃ©'], 403);
        }

        if (!in_array($session->status, ['active', 'paused'])) {
            return response()->json([
                'error' => 'Seules les sessions actives ou en pause peuvent Ãªtre terminÃ©es'
            ], 400);
        }

        $session->update([
            'status' => 'completed',
            'completed_at' => now()
        ]);

        return response()->json([
            'message' => 'Session terminÃ©e avec succÃ¨s',
            'session' => $session
        ]);
    }

    /**
     * Mettre en pause une session
     */
    public function pause($id)
    {
        $teacher = Auth::user()->teacher;

        $session = QuizSession::findOrFail($id);

        if (!$teacher || $session->teacher_id !== $teacher->id) {
            return response()->json(['error' => 'Non autorisÃ©'], 403);
        }

        if ($session->status !== 'active') {
            return response()->json([
                'error' => 'Seules les sessions actives peuvent Ãªtre mises en pause'
            ], 400);
        }

        $session->update([
            'status' => 'paused'
        ]);

        return response()->json([
            'message' => 'Session mise en pause avec succÃ¨s',
            'session' => $session
        ]);
    }

    /**
     * Reprendre une session en pause
     */
    public function resume($id)
    {
        $teacher = Auth::user()->teacher;

        $session = QuizSession::findOrFail($id);

        if (!$teacher || $session->teacher_id !== $teacher->id) {
            return response()->json(['error' => 'Non autorisÃ©'], 403);
        }

        if ($session->status !== 'paused') {
            return response()->json(['error' => 'Seules les sessions en pause peuvent Ãªtre reprises'], 400);
        }

        $session->update([
            'status' => 'active'
        ]);

        return response()->json([
            'message' => 'Session reprise avec succÃ¨s',
            'session' => $session
        ]);
    }

    /**
     * Annuler une session
     */
    public function cancel($id)
    {
        $teacher = Auth::user()->teacher;

        $session = QuizSession::findOrFail($id);

        if (!$teacher || $session->teacher_id !== $teacher->id) {
            return response()->json(['error' => 'Non autorisÃ©'], 403);
        }

        if (in_array($session->status, ['completed', 'cancelled'])) {
            return response()->json(['error' => 'Cette session ne peut plus Ãªtre annulÃ©e'], 400);
        }

        $session->update([
            'status' => 'cancelled'
        ]);

        return response()->json([
            'message' => 'Session annulÃ©e avec succÃ¨s',
            'session' => $session
        ]);
    }

    /**
     * âœ… Validation complÃ¨te avec vÃ©rification d'institution
     */
    private function validateStudentsInstitution($studentIds, $teacher)
    {
        // VÃ©rifier que tous les Ã©tudiants existent et sont actifs
        $validStudents = Student::with('classe.formation')
            ->whereIn('id', $studentIds)
            ->where('is_active', true)
            ->get();

        if ($validStudents->count() !== count($studentIds)) {
            $foundIds = $validStudents->pluck('id')->toArray();
            $missingIds = array_diff($studentIds, $foundIds);
            
            throw ValidationException::withMessages([
                'allowed_students' => [
                    'Les Ã©tudiants suivants sont introuvables ou inactifs: ' . implode(', ', $missingIds)
                ]
            ]);
        }

        // âœ… VALIDATION D'INSTITUTION ACTIVÃ‰E
        // Comment obtenir l'institution du professeur ?
        $teacherInstitutionId = $this->getTeacherInstitutionId($teacher);
        
        if ($teacherInstitutionId) {
            $studentsNotInInstitution = $validStudents->filter(function($student) use ($teacherInstitutionId) {
                // VÃ©rifier via la chaÃ®ne : student -> classe -> formation -> institution
                return $student->classe->formation->institution_id !== $teacherInstitutionId;
            });

            if ($studentsNotInInstitution->count() > 0) {
                $invalidIds = $studentsNotInInstitution->pluck('id')->toArray();
                throw ValidationException::withMessages([
                    'allowed_students' => [
                        'Les Ã©tudiants suivants ne font pas partie de votre institution: ' . implode(', ', $invalidIds)
                    ]
                ]);
            }
        }
        
        Log::info('Students validation passed', [
            'student_ids' => $studentIds,
            'teacher_id' => $teacher->id,
            'institution_validated' => true
        ]);
    }

    /**
     * Obtenir l'institution_id du professeur
     * Ã€ adapter selon votre structure de donnÃ©es
     */
    private function getTeacherInstitutionId($teacher)
    {
        // Option 1: Si le teacher a directement institution_id
        if (isset($teacher->institution_id)) {
            return $teacher->institution_id;
        }
        
        // Option 2: Si le teacher est liÃ© via une autre relation
        // Exemple: teacher -> subject -> formation -> institution
        /*
        if ($teacher->subjects()->exists()) {
            return $teacher->subjects()->first()->formation->institution_id;
        }
        */
        
        // Option 3: Via l'utilisateur administrateur (si applicable)
        /*
        $admin = $teacher->user->administrator;
        if ($admin) {
            return $admin->institution_id;
        }
        */
        
        // Ã€ adapter selon votre structure !
        Log::warning('Unable to determine teacher institution', ['teacher_id' => $teacher->id]);
        return null;
    }
}